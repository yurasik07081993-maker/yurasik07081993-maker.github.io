<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Desert Defense: Overload Edition</title>
    <script src="https://yandex.ru/ads/system/context.js" async></script>
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: #333;
            font-family: 'Arial Rounded MT Bold', 'Helvetica Rounded', Arial, sans-serif;
            user-select: none; -webkit-tap-highlight-color: transparent;
            display: flex; flex-direction: column;
        }

        canvas { display: block; width: 100%; height: 100%; touch-action: none; }

        /* UI –≠–ª–µ–º–µ–Ω—Ç—ã */
        #top-bar {
            position: absolute; top: 0; left: 0; width: 100%; height: 10%;
            background: rgba(0,0,0,0.6); border-bottom: 2px solid #333; z-index: 20;
            display: flex; align-items: center; justify-content: space-between; padding: 0 15px; box-sizing: border-box;
            backdrop-filter: blur(5px); min-height: 50px;
        }
        .ui-group { display: flex; gap: 10px; align-items: center; }
        .ui-box {
            background: #d4a76a; border: 2px solid #3e2723; border-radius: 8px;
            padding: 5px 12px; display: flex; align-items: center; color: #fff;
            text-shadow: 1px 1px 0 #000; box-shadow: 0 4px 0 #8c6a45; font-size: 16px; white-space: nowrap;
        }
        .icon-btn {
            background: #fbc02d; border: 2px solid #f57f17; border-radius: 8px;
            width: 40px; height: 40px; cursor: pointer; font-size: 20px;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 0 #c49000; transition: transform 0.1s;
        }
        .icon-btn:active { transform: translateY(4px); box-shadow: 0 0 0; }

        #base-health-bar-container { flex-grow: 1; margin: 0 15px; height: 15px; background: #333; border: 2px solid #000; border-radius: 12px; position: relative; overflow: hidden; }
        #base-health-bar { height: 100%; background: linear-gradient(to bottom, #ff4444, #cc0000); width: 100%; transition: width 0.2s; }

        #cost-info {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: white; padding: 10px 20px; border-radius: 30px;
            border: 2px solid #fff; font-size: 14px; z-index: 20; pointer-events: none;
            text-shadow: 1px 1px 2px black; width: 90%; text-align: center; box-sizing: border-box; max-width: 600px;
        }

        .overlay-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(212, 167, 106, 0.95); z-index: 50;
            display: none; flex-direction: column; align-items: center; justify-content: center;
        }
        #start-screen { display: flex; }
        .overlay-content {
            background: #d4a76a; padding: 30px; border: 6px solid #333; border-radius: 20px;
            text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.7); max-width: 400px; width: 80%;
        }
        .overlay-screen h1 { margin: 0; font-size: 32px; color: #3e2723; text-shadow: 2px 2px 0 #fff; }

        .subtitle { color: #fff; display: block; margin-top: 5px; }

        .big-btn {
            background: #4caf50; border: 3px solid #2e7d32; padding: 15px 40px; color: white; font-size: 22px;
            border-radius: 10px; cursor: pointer; box-shadow: 0 6px 0 #1b5e20; margin-top: 20px; font-weight: bold; display: inline-block;
        }
        .big-btn:active { transform: translateY(4px); box-shadow: 0 2px 0 #1b5e20; }

        #general-overlay {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); z-index: 60; align-items: center; justify-content: center;
        }
        .general-box {
            background: #fff3e0; border: 6px solid #5d4037; border-radius: 20px;
            padding: 20px; width: 90%; max-width: 600px; display: flex; flex-direction: column; gap: 20px;
            box-shadow: 0 25px 60px rgba(0,0,0,0.9);
        }
        @media (min-width: 600px) { .general-box { flex-direction: row; align-items: flex-start; } }

        .general-portrait {
            width: 100px; height: 120px; background: #795548; border: 4px solid #3e2723;
            border-radius: 10px; flex-shrink: 0; position: relative; overflow: hidden;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.3); margin: 0 auto;
        }
        .general-portrait::before { content: ''; position: absolute; top: 10px; left: 5%; width: 90%; height: 30px; background: #3e2723; border-radius: 5px 5px 0 0; }
        .general-portrait::after { content: '‚òÖ'; position: absolute; top: 12px; left: 50%; transform: translateX(-50%); color: gold; font-size: 24px; }
        .general-face { position: absolute; bottom: 0; left: 15%; width: 70%; height: 80px; background: #d7ccc8; border-radius: 40% 40% 0 0; border: 3px solid #3e2723; border-bottom: none; }
        .general-text-area { flex-grow: 1; }
        .general-dialogue-box {
            background: #fff; border: 3px solid #3e2723; padding: 15px; border-radius: 10px;
            color: #3e2723; font-size: 16px; line-height: 1.4; min-height: 80px;
        }

        #rotate-device {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #2d3436; z-index: 9999;
            flex-direction: column; align-items: center; justify-content: center;
            color: #fff; text-align: center; padding: 20px; box-sizing: border-box;
        }
        .rotate-icon { font-size: 80px; margin-bottom: 20px; animation: rotateAnim 2s infinite; }
        @keyframes rotateAnim { 0% { transform: rotate(0deg); } 25% { transform: rotate(-90deg); } 100% { transform: rotate(-90deg); } }

        @media screen and (orientation: portrait) { #rotate-device { display: flex; } }
        @media (max-width: 480px) { .ui-box { font-size: 12px; padding: 4px 8px; } .icon-btn { width: 30px; height: 30px; font-size: 14px; } h1 { font-size: 24px !important; } }

        #charge-prompt-btn {
            position: absolute; width: 50px; height: 50px; background: #00d2ff; border: 3px solid #fff;
            border-radius: 50%; color: white; display: none; align-items: center; justify-content: center;
            font-size: 24px; cursor: pointer; z-index: 40; box-shadow: 0 0 20px #00d2ff;
            animation: pulse-blue 1s infinite;
        }
        @keyframes pulse-blue { 0% { transform: scale(1); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }
    </style>
</head>
<body>

<div id="rotate-device"><div class="rotate-icon">üì±üîÑ</div><h2 style="font-size: 24px;">–ü–û–í–ï–†–ù–ò–¢–ï –£–°–¢–†–û–ô–°–¢–í–û</h2><p>–î–ª—è –∏–≥—Ä—ã –Ω–µ–æ–±—Ö–æ–¥–∏–º –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º</p></div>

<div id="charge-prompt-btn" onclick="applyTowerOverload()">‚ö°</div>

<div id="top-bar">
    <div class="ui-group">
        <div class="ui-box">üí∞ <span id="money">350</span></div>
        <div class="ui-box">üè∞ <span id="tower-count">0</span>/10</div>
    </div>
    <div id="base-health-bar-container"><div id="base-health-bar"></div></div>
    <div class="ui-group">
        <div class="ui-box">üåä <span id="wave">1</span>/10</div>
        <button class="icon-btn" style="background:#e74c3c; border-color:#c0392b;" onclick="triggerAirstrike()">‚úàÔ∏è</button>
        <button class="icon-btn" id="btn-pause" onclick="togglePause()">‚è∏</button>
        <button class="icon-btn" id="btn-mute" onclick="toggleMute()">üîä</button>
    </div>
</div>

<div id="cost-info">–ü—É—à–∫–∞ ($100) | –ê–≤–∏–∞—É–¥–∞—Ä ($1000) | –ú–∞–∫—Å 10</div>

<div id="start-screen" class="overlay-screen">
    <div class="overlay-content">
        <h1>–ó–ê–©–ò–¢–ê –ü–£–°–¢–´–ù–ò.</h1>
        <h1 class="subtitle">–ë–ê–®–ù–ò.</h1>
        <button class="big-btn" onclick="startGame()">–í –ë–û–ô!</button>
    </div>
</div>

<div id="general-overlay">
    <div class="general-box">
        <div class="general-portrait"><div class="general-face"></div></div>
        <div class="general-text-area">
            <div class="general-dialogue-box" id="general-text"></div>
            <button class="big-btn" id="general-ok-btn" style="float: right; margin-top: 10px; padding: 8px 20px; font-size: 16px;">–û–ö</button>
        </div>
    </div>
</div>

<div id="game-over" class="overlay-screen">
    <div class="overlay-content">
        <h1 id="go-title" style="color:#b71c1c;">–ë–ê–ó–ê –†–ê–ó–†–£–®–ï–ù–ê</h1>
        <p>–í–æ–ª–Ω–∞: <b id="final-wave">1</b></p>
        <button class="big-btn" onclick="location.reload()">–ï–©–Å –†–ê–ó</button>
    </div>
</div>

<div id="yandex_ad_container"></div>
<canvas id="gameCanvas"></canvas>

<script>
    window.yaContextCb = window.yaContextCb || [];
    const AD_ID = '18620446';

    function showAd() {
        if (window.Ya && window.Ya.Context) {
            window.Ya.Context.AdvManager.render({ blockId: AD_ID, renderTo: 'yandex_ad_container', type: 'fullscreen', onRender: () => { console.log('Ad rendered'); }, onClose: () => { console.log('Ad closed'); } });
        }
    }

    class SoundManager {
        constructor() { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); this.master = this.ctx.createDynamicsCompressor(); this.master.threshold.value = -12; this.master.ratio.value = 12; this.master.connect(this.ctx.destination); this.muted = false; this.musicStarted = false; this.gainNode = this.ctx.createGain(); this.gainNode.connect(this.master); this.noiseBuffer = this.createNoise(); }
        resume() { if (this.ctx.state === 'suspended') this.ctx.resume(); }
        toggleMute() { this.muted = !this.muted; this.gainNode.gain.setValueAtTime(this.muted ? 0 : 1, this.ctx.currentTime); document.getElementById('btn-mute').innerText = this.muted ? 'üîá' : 'üîä'; }
        createNoise() { const bs = this.ctx.sampleRate * 2; const buf = this.ctx.createBuffer(1, bs, this.ctx.sampleRate); const d = buf.getChannelData(0); for(let i=0;i<bs;i++) d[i]=Math.random()*2-1; return buf; }
        startArabianMusic() { if(this.musicStarted) return; this.musicStarted = true; let beatStep = 0; setInterval(() => { if(isPaused || this.muted) return; const now = this.ctx.currentTime; const step = beatStep % 16; if (step === 0 || step === 8) this.playDrumHit(now, 60, 0.4); if (step === 10) this.playDrumHit(now, 55, 0.3); if (step === 3) this.playDrumHit(now, 110, 0.15); if (step === 7) this.playDrumHit(now, 140, 0.25); if (step === 15) this.playDrumHit(now, 100, 0.2); if (step === 2 || step === 6 || step === 14) this.playShaker(now, 0.04); if (step === 4 || step === 12) this.playShaker(now, 0.1); beatStep++; }, 180); }
        playDrumHit(t, freq, vol) { if(this.muted) return; const osc = this.ctx.createOscillator(); const g = this.ctx.createGain(); osc.type = 'sine'; osc.frequency.setValueAtTime(freq * 1.5, t); osc.frequency.exponentialRampToValueAtTime(freq * 0.8, t + 0.15); g.gain.setValueAtTime(vol, t); g.gain.exponentialRampToValueAtTime(0.01, t + 0.15); osc.connect(g); g.connect(this.gainNode); osc.start(t); osc.stop(t + 0.15); }
        playShaker(t, vol) { if(this.muted) return; const src = this.ctx.createBufferSource(); const g = this.ctx.createGain(); const f = this.ctx.createBiquadFilter(); src.buffer = this.noiseBuffer; f.type = 'highpass'; f.frequency.value = 3000; src.connect(f); f.connect(g); g.connect(this.gainNode); g.gain.setValueAtTime(vol, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.05); src.start(t); src.stop(t + 0.06); }
        playShoot() { if(this.muted) return; const t = this.ctx.currentTime; const osc = this.ctx.createOscillator(); const g = this.ctx.createGain(); osc.type = 'triangle'; osc.frequency.setValueAtTime(100, t); g.gain.setValueAtTime(0.3, t); g.gain.exponentialRampToValueAtTime(0.01, t+0.15); osc.connect(g); g.connect(this.gainNode); osc.start(t); osc.stop(t+0.15); const src=this.ctx.createBufferSource(); src.buffer=this.noiseBuffer; const f=this.ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=600; const ng=this.ctx.createGain(); ng.gain.setValueAtTime(0.2, t); ng.gain.exponentialRampToValueAtTime(0.01, t+0.2); src.connect(f); f.connect(ng); ng.connect(this.gainNode); src.start(t); src.stop(t+0.25); }
        playExplosion() { if(this.muted) return; const t=this.ctx.currentTime; const src=this.ctx.createBufferSource(); src.buffer=this.noiseBuffer; const f=this.ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=500; const g=this.ctx.createGain(); g.gain.setValueAtTime(0.5,t); g.gain.exponentialRampToValueAtTime(0.01,t+0.5); src.connect(f); f.connect(g); g.connect(this.gainNode); src.start(t); src.stop(t+0.6); }
        playBuild() { if(this.muted) return; const t=this.ctx.currentTime; const o=this.ctx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(300,t); o.frequency.exponentialRampToValueAtTime(50,t+0.1); const g=this.ctx.createGain(); g.gain.setValueAtTime(0.2,t); g.gain.exponentialRampToValueAtTime(0.01,t+0.1); o.connect(g); g.connect(this.gainNode); o.start(t); o.stop(t+0.1); }
    }
    const sounds = new SoundManager();

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let s = 1; let gameStarted = false; let isPaused = false; let money = 350; let wave = 1;
    const MAX_HEALTH = 1000; let baseHealth = MAX_HEALTH;
    let BASE_X = 0; const TOWER_COST = 100; const MAX_TOWERS = 10;
    let enemies=[], towers=[], projectiles=[], particles=[];
    let enemiesQueue = []; let spawnTimer=0; let waveInProgress=false; let waveDelay=0;
    let path = []; let decor = [];

    let chargeTower = null;
    let chargeTimer = 0;

    const DIALOGUE_START = "–ü—Ä–∏–∫–∞–∑—ã–≤–∞—é –ø—Ä–æ–¥–µ—Ä–∂–∞—Ç—å—Å—è –Ω–∞ –¥–∞–Ω–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏ –ª—é–±–æ–π —Ü–µ–Ω–æ–π –∏ –Ω–µ –¥–∞—Ç—å –≤—Ä–∞–≥–∞–º –¥–æ–±—Ä–∞—Ç—å—Å—è –¥–æ –±–∞–∑—ã. –£ –Ω–∞—à–µ–≥–æ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–≥–æ –æ—Ç–¥–µ–ª–∞ –µ—Å—Ç—å –∫–∞–∫–æ–π —Ç–æ –ø–ª–∞–Ω... —á—Ç–æ —Ç–æ —Ç–∞–º —Å —Ç—É—Ä–µ–ª—è–º–∏... –í –æ–±—â–µ–º —Ç–∞–º —Ä–∞–∑–±–µ—Ä—ë—Ç–µ—Å—å. –í—ã–ø–æ–ª–Ω—è–π—Ç–µ!";
    const DIALOGUE_WIN = "–û—Ç–ª–∏—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞! –í—Ä–∞–≥ —Ä–∞–∑–±–∏—Ç. –ù–∞–∑–Ω–∞—á–∞—é —Ç–µ–±—è –≥–µ–Ω–µ—Ä–∞–ª–æ–º!";
    const DIALOGUE_LOSS = "–ë–∞–∑–∞ –ø–æ—Ç–µ—Ä—è–Ω–∞... –ú—ã –æ—Ç—Å—Ç—É–ø–∞–µ–º. –¢—ã —É–≤–æ–ª–µ–Ω.";

    // resize —Ç–µ–ø–µ—Ä—å –Ω–µ —Å–±—Ä–∞—Å—ã–≤–∞–µ—Ç –¥–µ–∫–æ—Ä
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; s = Math.max(0.1, Math.min(canvas.width, canvas.height) / 720); initPath(); }
    
    function initPath() { BASE_X = Math.min(220 * s, canvas.width * 0.2); path = [{x: canvas.width + 50*s, y: canvas.height * 0.2}, {x: canvas.width * 0.75, y: canvas.height * 0.25}, {x: canvas.width * 0.55, y: canvas.height * 0.7}, {x: canvas.width * 0.35, y: canvas.height * 0.5}, {x: BASE_X + 40*s, y: canvas.height * 0.6}]; }
    
    function initDecor(){ 
        decor=[]; 
        let attempts = 0;
        while(decor.length < 15 && attempts < 200) { 
            attempts++;
            let x = Math.random()*canvas.width; 
            let y = Math.random()*canvas.height; 
            let overlap = false; 
            path.forEach(p => { if (Math.hypot(p.x-x, p.y-y) < 80*s) overlap = true; }); 
            decor.forEach(d => { if (Math.hypot(d.x-x, d.y-y) < 60*s) overlap = true; });
            if(!overlap) decor.push({t: Math.random()>0.5?'rock':'cactus', x:x, y:y, s:0.5+Math.random()}); 
        } 
    }

    function drawPoly(pts, c, sc) { ctx.beginPath(); ctx.moveTo(pts[0].x,pts[0].y); for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y); ctx.closePath(); if(sc){ctx.save(); ctx.translate(4*s,4*s); ctx.fillStyle=sc; ctx.fill(); ctx.restore();} ctx.fillStyle=c; ctx.fill(); ctx.lineWidth=3*s; ctx.strokeStyle='#000'; ctx.stroke(); }
    function drawCircle(x,y,r,c,sc) { if(sc){ctx.beginPath();ctx.arc(x+4*s,y+4*s,r,0,Math.PI*2);ctx.fillStyle=sc;ctx.fill();} ctx.beginPath();ctx.arc(x,y,r,0,Math.PI*2);ctx.fillStyle=c;ctx.fill();ctx.lineWidth=3*s;ctx.strokeStyle='#000';ctx.stroke(); }

    function drawBackground() {
        let g=ctx.createLinearGradient(0,0,0,canvas.height); g.addColorStop(0,'#e6c288'); g.addColorStop(1,'#dcb374'); ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#c9a773'; ctx.beginPath(); ctx.moveTo(BASE_X,canvas.height*0.4); ctx.quadraticCurveTo(canvas.width*0.5,canvas.height*0.2,canvas.width,canvas.height*0.5); ctx.lineTo(canvas.width,0); ctx.lineTo(BASE_X,0); ctx.fill();
        ctx.save(); const barnX = canvas.width * 0.8; const barnY = canvas.height * 0.8; ctx.translate(barnX, barnY); ctx.scale(s, s); ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.beginPath(); ctx.moveTo(-60,0); ctx.lineTo(60,0); ctx.lineTo(70,40); ctx.lineTo(-70,40); ctx.fill(); ctx.beginPath(); ctx.moveTo(-60,0); ctx.lineTo(60,0); ctx.lineTo(60,-50); ctx.lineTo(-60,-50); ctx.closePath(); ctx.fillStyle='#8d6e63'; ctx.fill(); ctx.lineWidth=3; ctx.strokeStyle='#000'; ctx.stroke(); ctx.beginPath(); ctx.moveTo(-70,-50); ctx.lineTo(0,-90); ctx.lineTo(70,-50); ctx.lineTo(50,-40); ctx.lineTo(0,-70); ctx.lineTo(-50,-40); ctx.closePath(); ctx.fillStyle='#a1887f'; ctx.fill(); ctx.stroke(); ctx.lineWidth=4; ctx.strokeStyle='#3e2723'; ctx.beginPath(); ctx.moveTo(-40,-50); ctx.lineTo(-10,-80); ctx.stroke(); ctx.beginPath(); ctx.moveTo(20,-50); ctx.lineTo(50,-20); ctx.stroke(); ctx.fillStyle='#3e2723'; ctx.beginPath(); ctx.moveTo(-20,0); ctx.lineTo(20,0); ctx.lineTo(10,-30); ctx.lineTo(-15,-25); ctx.fill(); ctx.restore();
        ctx.save(); ctx.lineWidth=60*s; ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle='rgba(0,0,0,0.1)'; ctx.beginPath(); ctx.moveTo(path[0].x,path[0].y+5*s); path.slice(1).forEach(p=>ctx.lineTo(p.x,p.y+5*s)); ctx.stroke(); ctx.strokeStyle='#c2a06b'; ctx.beginPath(); ctx.moveTo(path[0].x,path[0].y); path.slice(1).forEach(p=>ctx.lineTo(p.x,p.y)); ctx.stroke(); ctx.lineWidth=2*s; ctx.strokeStyle='#a88a5b'; ctx.setLineDash([10*s,15*s]); ctx.beginPath(); ctx.moveTo(path[0].x,path[0].y-15*s); path.slice(1).forEach(p=>ctx.lineTo(p.x,p.y-15*s)); ctx.stroke(); ctx.beginPath(); ctx.moveTo(path[0].x,path[0].y+15*s); path.slice(1).forEach(p=>ctx.lineTo(p.x,p.y+15*s)); ctx.stroke(); ctx.restore();
        decor.sort((a,b)=>a.y-b.y); decor.forEach(d=>{ ctx.save(); ctx.translate(d.x,d.y); ctx.scale(d.s*s, d.s*s); if(d.t=='rock'){ ctx.beginPath();ctx.arc(4,4,20,0,Math.PI*2);ctx.fillStyle='rgba(0,0,0,0.3)';ctx.fill(); ctx.beginPath();ctx.arc(0,0,20,0,Math.PI*2);ctx.fillStyle='#a69580';ctx.fill();ctx.lineWidth=3;ctx.strokeStyle='#000';ctx.stroke(); } else { ctx.fillStyle='rgba(0,0,0,0.3)'; ctx.fillRect(-8,-46,16,50); ctx.fillStyle='#4b8b3b'; ctx.fillRect(-10,-50,20,50); ctx.lineWidth=3; ctx.strokeStyle='#000'; ctx.strokeRect(-10,-50,20,50); ctx.beginPath();ctx.arc(-25,-30,8,0,Math.PI*2);ctx.fillStyle='#4b8b3b';ctx.fill();ctx.lineWidth=3;ctx.stroke(); ctx.fillRect(-25,-30,15,12); ctx.strokeRect(-25,-30,15,12); ctx.beginPath();ctx.arc(25,-40,8,0,Math.PI*2);ctx.fillStyle='#4b8b3b';ctx.fill();ctx.stroke(); ctx.fillRect(10,-40,15,12); ctx.strokeRect(10,-40,15,12); } ctx.restore(); });
    }

    function drawBase() {
        if (path.length === 0) return; const GATE_Y = path[path.length-1].y; const GH=140*s;
        ctx.fillStyle='#5d4037'; ctx.lineWidth=3*s; ctx.strokeStyle='#281813'; ctx.fillRect(BASE_X-20*s,0,20*s,GATE_Y-GH/2); ctx.strokeRect(BASE_X-20*s,0,20*s,GATE_Y-GH/2); ctx.fillRect(BASE_X-20*s,GATE_Y+GH/2,20*s,canvas.height-(GATE_Y+GH/2)); ctx.strokeRect(BASE_X-20*s,GATE_Y+GH/2,20*s,canvas.height-(GATE_Y+GH/2)); ctx.fillStyle='#3e2723'; ctx.fillRect(BASE_X-25*s,GATE_Y-GH/2,25*s,GH); ctx.lineWidth=4*s; ctx.strokeStyle='#111'; ctx.strokeRect(BASE_X-25*s,GATE_Y-GH/2,25*s,GH); ctx.beginPath(); ctx.moveTo(BASE_X-25*s,GATE_Y); ctx.lineTo(BASE_X,GATE_Y); ctx.stroke();
        function drawTower(x,y){ ctx.save(); ctx.translate(x,y); ctx.strokeStyle='#333'; ctx.lineWidth=4*s; ctx.beginPath(); ctx.moveTo(-20*s,80*s);ctx.lineTo(0,0);ctx.lineTo(20*s,80*s); ctx.stroke(); drawPoly([{x:-25*s,y:0},{x:25*s,y:0},{x:30*s,y:-40*s},{x:-30*s,y:-40*s}],'#6d4c41','#3e2723'); drawPoly([{x:-35*s,y:-40*s},{x:35*s,y:-40*s},{x:0,y:-60*s}],'#5d4037','#3e2723'); drawCircle(0,-65*s,10*s,'#888','#555'); ctx.restore(); }
        drawTower(BASE_X-60*s, GATE_Y-GH/2-50*s); drawTower(BASE_X-60*s, GATE_Y+GH/2+80*s);
    }

    class Enemy {
        constructor(type){
            this.type = type; this.idx=0; this.x=path[0].x; this.y=path[0].y;
            let baseHp = 200;
            if(type === 'light') { this.speed = 1.2 * s; baseHp = 200; this.reward = 15; this.scale = 0.8; this.colorMain = '#556b2f'; }
            else if (type === 'heavy') { this.speed = 0.7 * s; baseHp = 600; this.reward = 35; this.scale = 1.0; this.colorMain = '#333'; }
            else if (type === 'boss') { this.speed = 0.4 * s; baseHp = 3200; this.reward = 150; this.scale = 1.5; this.colorMain = '#8b0000'; }
            let hpBonus = (wave > 1) ? (wave - 1) * 150 : 0;
            this.hp = baseHp + hpBonus; this.maxHp = this.hp; this.angle=0;
        }
        update(enemyAhead){
            let currentSpeed = this.speed;
            if (enemyAhead) { let dist = Math.hypot(enemyAhead.x - this.x, enemyAhead.y - this.y); if (dist < 150 * s) { currentSpeed = Math.min(this.speed, 0.5 * s); if (dist < 100 * s) currentSpeed = 0; } }
            if(this.idx < path.length-1){
                let t = path[this.idx+1]; let dx = t.x - this.x; let dy = t.y - this.y; let d = Math.hypot(dx, dy); this.angle = Math.atan2(dy, dx);
                if(d < currentSpeed){ this.x = t.x; this.y = t.y; this.idx++; } else { this.x += Math.cos(this.angle) * currentSpeed; this.y += Math.sin(this.angle) * currentSpeed; }
            } else { baseHealth -= (this.type === 'boss' ? 300 : 50); this.hp = 0; sounds.playExplosion(); createExplosion(this.x, this.y, 30); updateUI(); }
        }
        draw(){
            ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle); ctx.scale(this.scale, this.scale);
            ctx.fillStyle='rgba(0,0,0,0.3)'; ctx.beginPath(); ctx.ellipse(0,5*s,30*s,18*s,0,0,Math.PI*2); ctx.fill();
            drawPoly([{x:-25*s,y:-18*s},{x:25*s,y:-18*s},{x:22*s,y:-8*s},{x:-22*s,y:-8*s}], this.colorMain, '#111');
            drawPoly([{x:-25*s,y:18*s},{x:25*s,y:18*s},{x:22*s,y:8*s},{x:-22*s,y:8*s}], this.colorMain, '#111');
            let towerColor = this.type === 'light' ? '#6b8e23' : (this.type === 'boss' ? '#b71c1c' : '#4b5320');
            drawPoly([{x:-22*s,y:-12*s},{x:22*s,y:-12*s},{x:25*s,y:0},{x:22*s,y:12*s},{x:-22*s,y:12*s}], towerColor, '#222');
            drawCircle(0,0,12*s, this.type === 'boss' ? '#e53935' : '#5d6b30', '#3e4a20');
            ctx.fillStyle=towerColor; ctx.lineWidth=3*s; ctx.strokeStyle='#000'; ctx.fillRect(10*s,-4*s,25*s,8*s); ctx.strokeRect(10*s,-4*s,25*s,8*s);
            ctx.rotate(-this.angle);
            ctx.fillStyle='black'; ctx.fillRect(-20*s,-30*s,40*s,6*s);
            ctx.fillStyle=this.hp>this.maxHp*0.5?'#00ff00':'#ff0000'; ctx.fillRect(-18*s,-28*s,36*s*(Math.max(0,this.hp)/this.maxHp),4*s);
            ctx.restore();
        }
    }

    class Tower {
        constructor(x,y){
            this.x=x;this.y=y;this.lvl=1;this.range=180*s;this.dmg=40;this.cd=30;this.tm=0;this.angle=0;this.recoil=0;
            this.overloaded = false;
            this.overloadTimer = 0;
            this.maxOverload = 900;
        }
        update(){
            if(this.recoil > 0) this.recoil -= 0.5;
            if(this.tm > 0) this.tm--;
            let finalCD = this.cd;
            let finalDmg = this.dmg;
            if(this.overloaded) {
                finalCD = 7; finalDmg = 150; this.overloadTimer--;
                if(this.overloadTimer <= 0) {
                    createExplosion(this.x, this.y, 40); sounds.playExplosion();
                    towers = towers.filter(t => t !== this); updateUI(); return;
                }
            }
            let t=null, maxD=-1; enemies.forEach(e=>{if(Math.hypot(e.x-this.x,e.y-this.y)<=this.range && e.idx>maxD){maxD=e.idx;t=e;}});
            if(t){
                let ta=Math.atan2(t.y-this.y,t.x-this.x), diff=ta-this.angle;
                while(diff<-Math.PI)diff+=Math.PI*2; while(diff>Math.PI)diff-=Math.PI*2;
                this.angle+=diff*0.3;
                if(this.tm<=0 && Math.abs(diff)<0.5){
                    projectiles.push(new Projectile(this.x+Math.cos(this.angle)*25*s,this.y+Math.sin(this.angle)*25*s,t,finalDmg));
                    this.tm=finalCD; this.recoil = 6;
                    createMuzzleFlash(this.x+Math.cos(this.angle)*30*s,this.y+Math.sin(this.angle)*30*s); sounds.playShoot();
                }
            }
        }
        draw(){
            ctx.save(); ctx.translate(this.x,this.y);
            if(this.overloaded) {
                ctx.beginPath(); ctx.arc(0,0,30*s,0,Math.PI*2);
                ctx.fillStyle = `rgba(0, 210, 255, ${0.2 + Math.sin(Date.now()/100)*0.1})`; ctx.fill();
                const barWidth = 50 * s; const barHeight = 6 * s;
                const currentWidth = (this.overloadTimer / this.maxOverload) * barWidth;
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(-barWidth/2, -45*s, barWidth, barHeight);
                ctx.shadowBlur = 10; ctx.shadowColor = '#00d2ff'; ctx.fillStyle = '#00d2ff';
                ctx.fillRect(-barWidth/2, -45*s, currentWidth, barHeight); ctx.shadowBlur = 0;
            }
            drawCircle(0,0,22*s,'#999','#666'); ctx.rotate(this.angle); ctx.translate(-this.recoil*s, 0);
            let color = this.overloaded ? '#00d2ff' : '#667788';
            drawPoly([{x:-15*s,y:-12*s},{x:10*s,y:-12*s},{x:15*s,y:0},{x:10*s,y:12*s},{x:-15*s,y:12*s}], color ,'#445566');
            ctx.fillStyle='#333'; ctx.lineWidth=3*s; ctx.strokeStyle='#000';
            ctx.fillRect(15*s,-4*s,15*s,8*s);ctx.strokeRect(15*s,-4*s,15*s,8*s);
            ctx.fillStyle = this.overloaded ? '#fff' : '#00ff00'; ctx.fillRect(-5*s,-5*s,10*s,10*s);
            ctx.restore();
        }
    }

    class Projectile {
        constructor(x,y,t,d){this.x=x;this.y=y;this.t=t;this.d=d;this.s=14*s;this.a=true;}
        update(){
            if(!this.t||this.t.hp<=0){this.a=false;return;}
            let ang=Math.atan2(this.t.y-this.y,this.t.x-this.x);
            this.x+=Math.cos(ang)*this.s; this.y+=Math.sin(ang)*this.s;
            if(Math.hypot(this.t.x-this.x,this.t.y-this.y)<20*s){
                this.t.hp-=this.d; if(this.t.hp<=0){money+=this.t.reward;createExplosion(this.t.x,this.t.y,20);sounds.playExplosion();updateUI();}
                else createExplosion(this.x,this.y,5); this.a=false;
            }
        }
        draw(){ ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(Math.atan2(this.t.y-this.y,this.t.x-this.x)); drawPoly([{x:-8*s,y:-4*s},{x:4*s,y:-4*s},{x:8*s,y:0},{x:4*s,y:4*s},{x:-8*s,y:4*s}],'#ffcc00','#cc9900'); ctx.restore(); }
    }

    class Particle {
        constructor(x,y,type){this.x=x;this.y=y;this.life=type=='boom'?30:15;this.max=this.life;this.vx=(Math.random()-0.5)*5*s;this.vy=(Math.random()-0.5)*5*s;this.sz=(Math.random()*10+5)*s;this.c=type=='boom'?(Math.random()>0.5?'#ff5500':'#ffff00'):'#fff';}
        update(){this.x+=this.vx;this.y+=this.vy;this.life--;this.sz*=0.9;}
        draw(){ ctx.globalAlpha=this.life/this.max; ctx.beginPath(); ctx.arc(this.x,this.y,this.sz,0,Math.PI*2); ctx.fillStyle=this.c; ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle='#000'; ctx.stroke(); ctx.globalAlpha=1; }
    }
    function createExplosion(x,y,c){for(let i=0;i<c;i++)particles.push(new Particle(x,y,'boom'));}
    function createMuzzleFlash(x,y){for(let i=0;i<5;i++)particles.push(new Particle(x,y,'flash'));}

    function togglePause() { if(!gameStarted) return; isPaused = !isPaused; document.getElementById('btn-pause').innerText = isPaused ? '‚ñ∂' : '‚è∏'; }
    function toggleMute() { sounds.toggleMute(); }
    function showGeneral(text, callback) { document.getElementById('general-text').innerText = text; document.getElementById('general-overlay').style.display = 'flex'; document.getElementById('general-ok-btn').onclick = function() { document.getElementById('general-overlay').style.display = 'none'; if (callback) callback(); }; }
    
    function startGame() { 
        document.getElementById('start-screen').style.display = 'none'; 
        sounds.resume(); 
        const docEl = document.documentElement; 
        if (docEl.requestFullscreen) docEl.requestFullscreen(); 
        if (screen.orientation && screen.orientation.lock) screen.orientation.lock('landscape').catch(()=>{}); 
        resize(); 
        initDecor(); // –î–µ–∫–æ—Ä –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –û–î–ò–ù –†–ê–ó –ø—Ä–∏ –Ω–∞—á–∞–ª–µ –±–æ—è
        baseHealth = MAX_HEALTH; 
        showGeneral(DIALOGUE_START, actualGameStart); 
        startChargeTimer(); 
    }
    
    function actualGameStart() { sounds.startArabianMusic(); gameStarted = true; wave = 1; startWave(); }

    function startWave(){
        if(waveInProgress) return;
        waveInProgress = true; enemiesQueue = [];
        if(wave === 1) { for(let i=0; i<10; i++) enemiesQueue.push('light'); }
        else if (wave === 2) { for(let i=0; i<15; i++) enemiesQueue.push('light'); }
        else if (wave === 3) { for(let i=0; i<15; i++) enemiesQueue.push(i%3==0 ? 'heavy' : 'light'); }
        else if (wave === 4) { for(let i=0; i<15; i++) enemiesQueue.push('heavy'); }
        else if (wave === 5) { enemiesQueue.push('boss'); for(let i=0; i<10; i++) enemiesQueue.push('light'); }
        else if (wave === 6) { for(let i=0; i<30; i++) enemiesQueue.push('light'); }
        else if (wave === 7) { for(let i=0; i<20; i++) enemiesQueue.push('heavy'); }
        else if (wave === 8) { for(let i=0; i<20; i++) enemiesQueue.push(Math.random()>0.7 ? 'boss' : 'heavy'); }
        else if (wave === 9) { for(let i=0; i<40; i++) enemiesQueue.push(Math.random()>0.5 ? 'light' : 'heavy'); }
        else if (wave >= 10) { for(let i=0; i<5; i++) enemiesQueue.push('boss'); for(let i=0; i<20; i++) enemiesQueue.push('heavy'); }
        spawnTimer = 0; updateUI();
    }

    function triggerAirstrike() { if(money >= 1000) { money -= 1000; sounds.playExplosion(); enemies.forEach(e => { e.hp = 0; createExplosion(e.x, e.y, 20); }); updateUI(); } else { alert("–ù—É–∂–Ω–æ $1000!"); } }

    function startChargeTimer() {
        setInterval(() => {
            if(!gameStarted || isPaused || towers.length === 0) return;
            const liveTowers = towers.filter(t => !t.overloaded);
            if (liveTowers.length === 0) return;
            const target = liveTowers[Math.floor(Math.random() * liveTowers.length)];
            chargeTower = target;
            const btn = document.getElementById('charge-prompt-btn');
            btn.style.display = 'flex'; btn.style.left = (target.x - 25) + 'px'; btn.style.top = (target.y - 80) + 'px';
            setTimeout(() => { btn.style.display = 'none'; chargeTower = null; }, 5000);
        }, 40000);
    }

    function applyTowerOverload() {
        if(chargeTower) {
            chargeTower.overloaded = true; chargeTower.overloadTimer = 900;
            document.getElementById('charge-prompt-btn').style.display = 'none'; chargeTower = null;
        }
    }

    canvas.addEventListener('pointerdown',e=>{
        if(!gameStarted || isPaused) return;
        sounds.resume(); let x = e.clientX; let y = e.clientY;
        if(x < BASE_X + 30*s) return;
        let onRoad=false; path.forEach(p=>{if(Math.hypot(p.x-x,p.y-y) < 50*s) onRoad=true;}); if(onRoad)return;
        let free=true; for(let t of towers) if(Math.hypot(t.x-x,t.y-y) < 60*s) free=false;
        if(free && towers.length < MAX_TOWERS && money>=TOWER_COST){
            money-=TOWER_COST; towers.push(new Tower(x,y));
            sounds.playBuild(); createMuzzleFlash(x,y); updateUI();
            if(!waveInProgress) startWave();
        }
    });

    function updateUI(){
        document.getElementById('money').innerText=money; document.getElementById('wave').innerText=wave;
        document.getElementById('tower-count').innerText=towers.length;
        document.getElementById('base-health-bar').style.width=(Math.max(0,baseHealth)/MAX_HEALTH*100)+'%';
    }

    function loop(){
        requestAnimationFrame(loop);
        if(!gameStarted) { drawBackground(); drawBase(); return; }
        if(isPaused) return;
        drawBackground(); drawBase();
        if(waveInProgress){
            if(enemiesQueue.length > 0) {
                spawnTimer--;
                if(spawnTimer <= 0) {
                    let type = enemiesQueue.shift(); enemies.push(new Enemy(type));
                    spawnTimer = Math.max(120, 200 - wave*15);
                }
            }
            else if(enemies.length==0){
                waveInProgress=false;
                if(wave < 10) { wave++; waveDelay=180; }
                else { gameStarted = false; showGeneral(DIALOGUE_WIN, function() { document.getElementById('go-title').innerText = "–ü–û–ë–ï–î–ê!"; document.getElementById('go-title').style.color = "#4caf50"; document.getElementById('game-over').style.display='flex'; }); }
                updateUI();
            }
        } else { waveDelay--; if(waveDelay <= 0 && wave <= 10) startWave(); }
        towers.forEach(t=>t.update());
        for(let i=enemies.length-1;i>=0;i--){ let enemyAhead = (i > 0) ? enemies[i-1] : null; enemies[i].update(enemyAhead); if(enemies[i].hp<=0) enemies.splice(i,1); }
        for(let i=projectiles.length-1;i>=0;i--){projectiles[i].update();if(!projectiles[i].a)projectiles.splice(i,1);}
        for(let i=particles.length-1;i>=0;i--){particles[i].update();if(particles[i].life<=0)particles.splice(i,1);}
        [...enemies,...towers,...projectiles].sort((a,b)=>a.y-b.y).forEach(o=>o.draw());
        particles.forEach(p=>p.draw());
        if(gameStarted && baseHealth<=0){ gameStarted=false; showAd(); showGeneral(DIALOGUE_LOSS, function() { document.getElementById('final-wave').innerText=wave; document.getElementById('game-over').style.display='flex'; }); }
    }

    document.addEventListener('visibilitychange', () => {
        if (document.hidden && gameStarted && !isPaused) {
            togglePause();
        }
    });

    window.addEventListener('resize', resize);
    resize();
    loop();
</script>
</body>
</html>