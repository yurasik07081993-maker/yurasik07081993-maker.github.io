<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Steel Frontier - Final Polished</title>
    
    <script src="https://yandex.ru/games/sdk/v2"></script>

    <style>
        /* –ì–ª–æ–±–∞–ª—å–Ω—ã–π –∑–∞–ø—Ä–µ—Ç –≤—ã–¥–µ–ª–µ–Ω–∏—è */
        * {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        body, html { 
            margin: 0; 
            padding: 0; 
            width: 100%; 
            height: 100%; 
            overflow: hidden; 
            background: #1a252f;
            overscroll-behavior: none; 
            touch-action: none;
            cursor: default; 
        }
        
        /* –ö–∞–Ω–≤–∞—Å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (–∫—É—Ä—Å–æ—Ä –±—É–¥–µ—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å—Å—è —á–µ—Ä–µ–∑ JS) */
        canvas { display: none; touch-action: none; background: #fff; }
        
        /* –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω–æ cursor: default, —á—Ç–æ–±—ã –≤ –º–µ–Ω—é –∫—É—Ä—Å–æ—Ä –í–°–ï–ì–î–ê –±—ã–ª –≤–∏–¥–µ–Ω */
        #start-screen, #game-over, #victory-screen, #briefing-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, #2c3e50 0%, #000 100%); 
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100;
            color: white; font-family: sans-serif; text-transform: uppercase; letter-spacing: 2px;
            overflow: hidden;
            cursor: default !important; /* –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫—É—Ä—Å–æ—Ä –≤ –º–µ–Ω—é */
        }

        #game-over, #victory-screen, #briefing-overlay { display: none; z-index: 110; }

        #briefing-overlay { background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(5px); }
        .briefing-card {
            background: #1e272e; 
            border: 2px solid #34495e;
            box-shadow: 0 0 30px rgba(0,0,0,0.8), inset 0 0 20px rgba(44, 62, 80, 0.5);
            width: 90%; 
            max-width: 650px; 
            display: flex; 
            flex-direction: row; 
            align-items: center;
            padding: 30px;
            position: relative;
            border-left: 8px solid #ff4757;
        }

        .briefing-left {
            flex: 0 0 160px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-right: 1px solid rgba(255,255,255,0.1);
            margin-right: 25px;
            padding-right: 20px;
        }

        .general-label {
            color: #ff4757;
            font-weight: 900;
            font-size: 14px;
            text-align: center;
            border: 2px solid #ff4757;
            padding: 15px 10px;
            background: rgba(255, 71, 87, 0.1);
            text-shadow: 0 0 5px rgba(255, 71, 87, 0.5);
        }

        .briefing-text { 
            font-size: 16px; 
            line-height: 1.6; 
            margin-bottom: 25px; 
            letter-spacing: 0.5px; 
            text-transform: none; 
            color: #dff9fb;
            font-family: 'Courier New', Courier, monospace;
        }

        .scanline {
            width: 100%; height: 2px; background: rgba(0, 255, 128, 0.15);
            position: absolute; top: 0; left: 0; animation: scan 4s linear infinite; pointer-events: none;
        }
        @keyframes scan { from { top: 0; } to { top: 100%; } }

        .game-title, .end-title, .victory-title { 
            font-size: 42px; 
            margin: 0; 
            font-weight: 900; 
            margin-bottom: 10px; 
            position: relative; 
            text-align: center;
            padding: 0 40px;
        }

        .game-subtitle {
            font-size: 24px;
            color: #bdc3c7;
            font-weight: 700;
            letter-spacing: 6px;
            margin-bottom: 40px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }

        .game-title::before, .game-title::after,
        .end-title::before, .end-title::after,
        .victory-title::before, .victory-title::after {
            content: "";
            position: absolute;
            top: 15%;
            bottom: 15%;
            width: 15px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .game-title::before, .end-title::before, .victory-title::before { left: 0; border-right: none; }
        .game-title::after, .end-title::after, .victory-title::after { right: 0; border-left: none; }

        .game-title, .end-title { color: #ff4757; text-shadow: 0 0 15px rgba(255, 71, 87, 0.5); }
        .victory-title { color: #2ecc71; text-shadow: 0 0 15px rgba(46, 204, 113, 0.5); }

        .stats-text { font-size: 20px; margin-bottom: 20px; color: #bdc3c7; }

        .btn-start, .btn-victory { 
            padding: 12px 40px; 
            font-size: 16px; 
            background: #ff4757; 
            border: 2px solid #ff4757; 
            color: white; 
            cursor: pointer; 
            font-weight: bold; 
            box-shadow: 0 0 20px rgba(255, 71, 87, 0.3); 
            transition: transform 0.05s ease, background 0.1s, filter 0.1s; 
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            outline: none;
            border-radius: 4px;
        }

        .btn-start:active, .btn-victory:active {
            transform: scale(0.90);
            filter: brightness(0.8);
        }

        .btn-start:hover { 
            background: transparent; 
            color: #ff4757; 
        }

        .btn-victory { 
            background: #2ecc71; 
            border-color: #2ecc71; 
            box-shadow: 0 0 20px rgba(46, 204, 113, 0.3); 
        }
        
        .btn-victory:hover {
            background: transparent;
            color: #2ecc71;
        }
    </style>
</head>
<body>
    <div id="start-screen">
        <div class="scanline"></div>
        <h1 class="game-title" id="ui-title">–°–¢–ê–õ–¨–ù–û–ô –†–£–ë–ï–ñ.</h1>
        <div class="game-subtitle" id="ui-subtitle">–í–´–ñ–ò–í–ê–ù–ò–ï.</div>
        <button class="btn-start" id="ui-btn-start" onclick="startGame()" ontouchstart="">–ò–ù–ò–¶–ò–ò–†–û–í–ê–¢–¨ –ë–û–ô</button>
    </div>

    <div id="briefing-overlay">
        <div class="briefing-card">
            <div class="briefing-left">
                <div class="general-label" id="briefing-label">–ü–†–ò–ö–ê–ó<br>–ì–ï–ù–ï–†–ê–õ–ê</div>
            </div>
            <div class="briefing-right">
                <div class="briefing-text" id="briefing-text">
                    –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –º–∏—Å—Å–∏–∏...
                </div>
                <button class="btn-start" id="ui-btn-accept" onclick="startBattle()" ontouchstart="">–ü–†–ò–ù–Ø–¢–û</button>
            </div>
        </div>
    </div>

    <div id="game-over">
        <div class="scanline"></div>
        <h1 class="end-title" id="ui-game-over">–û–ë–™–ï–ö–¢ –£–ù–ò–ß–¢–û–ñ–ï–ù</h1>
        <button class="btn-start" id="ui-btn-return-fail" onclick="location.reload()" ontouchstart="">–í–ï–†–ù–£–¢–¨–°–Ø –í –®–¢–ê–ë</button>
    </div>

    <div id="victory-screen">
        <div class="scanline"></div>
        <h1 class="victory-title" id="ui-victory">–ü–û–ë–ï–î–ê!</h1>
        <div id="final-kills" class="stats-text">–£–ù–ò–ß–¢–û–ñ–ï–ù–û –í–†–ê–ì–û–í: 0</div>
        <button class="btn-start btn-victory" id="ui-btn-return-win" onclick="location.reload()" ontouchstart="">–í–ï–†–ù–£–¢–¨–°–Ø –í –®–¢–ê–ë</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const translations = {
            'ru': {
                title: "–°–¢–ê–õ–¨–ù–û–ô –†–£–ë–ï–ñ.",
                subtitle: "–í–´–ñ–ò–í–ê–ù–ò–ï.",
                startBtn: "–ò–ù–ò–¶–ò–ò–†–û–í–ê–¢–¨ –ë–û–ô",
                briefLabel: "–ü–†–ò–ö–ê–ó<br>–ì–ï–ù–ï–†–ê–õ–ê",
                brief1: "–ë–æ–µ—Ü, —Å–∏—Ç—É–∞—Ü–∏—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è! –¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî –ø—Ä–æ–¥–µ—Ä–∂–∞—Ç—å—Å—è 3 –º–∏–Ω—É—Ç—ã –¥–æ –ø—Ä–∏–±—ã—Ç–∏—è –ø–æ–¥–∫—Ä–µ–ø–ª–µ–Ω–∏—è. <br><br>–ò—Å–ø–æ–ª—å–∑—É–π –∞–≤—Ç–æ–Ω–æ–º–Ω—ã–µ —Ç—É—Ä–µ–ª–∏, —Ä–∞–∫–µ—Ç–Ω—É—é —É—Å—Ç–∞–Ω–æ–≤–∫—É –∏ —Ä—É—á–Ω–æ–µ –æ—Ä—É–¥–∏–µ. –°–ø–µ—Ü-–æ—Ä—É–∂–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–æ ‚Äî —É —Ç–µ–±—è –≤—Å–µ–≥–æ 5 –∑–∞—Ä—è–¥–æ–≤! <br><br>–£–¥–∞—á–∏, —Ç—ã ‚Äî –Ω–∞—à–∞ –ø–æ—Å–ª–µ–¥–Ω—è—è –Ω–∞–¥–µ–∂–¥–∞!",
                acceptBtn: "–ü–†–ò–ù–Ø–¢–û",
                gameOver: "–û–ë–™–ï–ö–¢ –£–ù–ò–ß–¢–û–ñ–ï–ù",
                returnBtn: "–í–ï–†–ù–£–¢–¨–°–Ø –í –®–¢–ê–ë",
                victory: "–ü–û–ë–ï–î–ê!",
                kills: "–£–ù–ò–ß–¢–û–ñ–ï–ù–û –í–†–ê–ì–û–í: ",
                level2Label: "–í–ù–ò–ú–ê–ù–ò–ï!<br>–£–†–û–í–ï–ù–¨ 2",
                level2Text: "–í—Ä–∞–≥ –æ—Ç—Å—Ç—É–ø–∞–µ—Ç, –Ω–æ –≤—ã—Å–ª–∞–ª —ç–ª–∏—Ç–Ω—ã–µ –æ—Ç—Ä—è–¥—ã –¥—Ä–æ–Ω–æ–≤. <br><br>–ò—Ö —Å–∫–æ—Ä–æ—Å—Ç—å —É–≤–µ–ª–∏—á–µ–Ω–∞, –±—Ä–æ–Ω—è —É—Å–∏–ª–µ–Ω–∞. <br><br>–î–µ—Ä–∂–∏—Ç–µ –æ–±–æ—Ä–æ–Ω—É –µ—â–µ 3 –º–∏–Ω—É—Ç—ã. –®—Ç–∞–± –≤—ã—Å—ã–ª–∞–µ—Ç –¥–æ–ø. –ø—Ä–∏–ø–∞—Å—ã. –î–µ–π—Å—Ç–≤—É–π!",
                level3Label: "–¢–†–ï–í–û–ì–ê!<br>–§–ò–ù–ê–õ",
                level3Text: "–ì–µ–Ω–µ—Ä–∞–ª: –í—Ä–∞–≥ –∑–∞–≥–Ω–∞–ª –Ω–∞—Å –≤ –ø—É—Å—Ç—ã–Ω–Ω—ã–π —Å–µ–∫—Ç–æ—Ä! <br><br>–ñ–∞—Ä–∞ –ø–ª–∞–≤–∏—Ç –±—Ä–æ–Ω—é, –Ω–æ –º—ã –Ω–µ —Å–¥–∞–¥–∏–º—Å—è.<br><br>–í—ã–∂–∏–≤–∏ –ª—é–±–æ–π —Ü–µ–Ω–æ–π! –≠—Ç–æ –Ω–∞—à –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ä—É–±–µ–∂.",
                clean: "–ó–ê–ß–ò–°–¢–ö–ê",
                pause: "–ü–ê–£–ó–ê"
            },
            'en': {
                title: "STEEL FRONTIER.",
                subtitle: "SURVIVAL.",
                startBtn: "INITIATE BATTLE",
                briefLabel: "GENERAL'S<br>ORDER",
                brief1: "Soldier, the situation is critical! Your task is to hold out for 3 minutes until reinforcements arrive. <br><br>Use autonomous turrets, rocket launchers, and your main gun. Special weapons are limited ‚Äî only 5 charges! <br><br>Good luck, you are our last hope!",
                acceptBtn: "ACCEPTED",
                gameOver: "UNIT DESTROYED",
                returnBtn: "RETURN TO BASE",
                victory: "VICTORY!",
                kills: "ENEMIES DESTROYED: ",
                level2Label: "WARNING!<br>LEVEL 2",
                level2Text: "The enemy is retreating but sent elite drone squads. <br><br>Increased speed, reinforced armor. <br><br>Hold the line for another 3 minutes. HQ is sending supplies. Act now!",
                level3Label: "ALARM!<br>FINAL",
                level3Text: "General: The enemy has cornered us in the desert sector! <br><br>The heat melts armor, but we won't surrender.<br><br>Survive at any cost. This is our last frontier.",
                clean: "CLEANUP",
                pause: "PAUSED"
            }
        };

        let currentLang = 'ru'; 

        function applyLanguage(lang) {
            if (lang !== 'ru' && lang !== 'be' && lang !== 'kk' && lang !== 'uk') {
                currentLang = 'en';
            } else {
                currentLang = 'ru';
            }
            const t = translations[currentLang];
            document.getElementById('ui-title').innerText = t.title;
            document.getElementById('ui-subtitle').innerText = t.subtitle;
            document.getElementById('ui-btn-start').innerText = t.startBtn;
            document.getElementById('briefing-label').innerHTML = t.briefLabel;
            document.getElementById('briefing-text').innerHTML = t.brief1;
            document.getElementById('ui-btn-accept').innerText = t.acceptBtn;
            document.getElementById('ui-game-over').innerText = t.gameOver;
            document.getElementById('ui-btn-return-fail').innerText = t.returnBtn;
            document.getElementById('ui-btn-return-win').innerText = t.returnBtn;
            document.getElementById('ui-victory').innerText = t.victory;
            if (document.getElementById('final-kills').innerText.includes(':')) {
                 document.getElementById('final-kills').innerText = t.kills + kills;
            }
        }

        let ysdk;
        function initYandexSDK() {
            if (typeof YaGames === 'undefined') return;
            YaGames.init().then(ysdkInstance => {
                ysdk = ysdkInstance;
                const lang = ysdk.environment.i18n.lang;
                applyLanguage(lang);
                console.log("Language detected: " + lang);
            });
        }

        function showFullscreenAd() {
            if (ysdk) {
                ysdk.adv.showFullscreenAdv({
                    callbacks: {
                        onOpen: () => { isPaused = true; },
                        onClose: function(wasShown) { isPaused = false; },
                        onError: function(error) { isPaused = false; }
                    }
                });
            }
        }

        function showRewardedAd() {
            if (ysdk) {
                ysdk.adv.showRewardedVideo({
                    callbacks: {
                        onOpen: () => { isPaused = true; },
                        onRewarded: () => { ultCharges += 3; },
                        onClose: () => { isPaused = false; },
                        onError: (e) => { isPaused = false; }
                    }
                });
            } else {
                ultCharges += 3;
            }
        }

        initYandexSDK();

        window.addEventListener('contextmenu', e => e.preventDefault());
        window.addEventListener('selectstart', e => e.preventDefault());
        window.addEventListener('dragstart', e => e.preventDefault());

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let audioCtx, masterGain, isRunning = false, isPaused = false, isGameOver = false, kills = 0, lives = 5, maxLives = 5, s = 1;
        let briefingActive = false, ultCharges = 5, currentLevel = 1, levelClearedTime = 0, flashAlpha = 0;
        let timeLeft = 180; 
        
        let projectiles = [], enemies = [], particles = [], snowflakes = [], rockets = [], turrets = [];
        let trees = [], iceBlocks = [], lastShotTime = 0, lastUltTime = 0, lastRocketTime = 0, lastTurretTime = 0;
        let groundSAM, victoryTriggered = false, isDefeated = false;
        
        const player = { x: 0, y: 0, angle: 0, targetAngle: 0, recoil: 0, radius: 55, turnSpeed: 0.12 };
        const touch = { joy: { active: false, startX: 0, startY: 0, curX: 0, curY: 0, r: 0, id: null }, btnFire: { active: false, x: 0, y: 0, r: 0 }, btnUlt: { active: false, x: 0, y: 0, r: 0 }, btnPause: { x: 0, y: 0, r: 0 } };

        function initAudio() { try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); masterGain = audioCtx.createGain(); masterGain.gain.setValueAtTime(0.5, audioCtx.currentTime); masterGain.connect(audioCtx.destination); } catch(e) {} }
        function playSound(type) { if (!audioCtx || audioCtx.state === 'suspended' || isPaused || briefingActive) return; const now = audioCtx.currentTime; if (type === 'shoot') { const osc = audioCtx.createOscillator(); const g = audioCtx.createGain(); osc.type = 'triangle'; osc.frequency.setValueAtTime(200, now); osc.frequency.exponentialRampToValueAtTime(50, now + 0.1); g.gain.setValueAtTime(0.12, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.2); osc.connect(g); g.connect(masterGain); osc.start(); osc.stop(now + 0.2); } else if (type === 'boom') { const osc = audioCtx.createOscillator(); const g = audioCtx.createGain(); osc.type = 'triangle'; osc.frequency.setValueAtTime(80, now); osc.frequency.exponentialRampToValueAtTime(20, now + 0.3); g.gain.setValueAtTime(0.07, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.3); osc.connect(g); g.connect(masterGain); osc.start(); osc.stop(now + 0.3); } else if (type === 'turret') { const osc = audioCtx.createOscillator(); const g = audioCtx.createGain(); osc.type = 'square'; osc.frequency.setValueAtTime(600, now); osc.frequency.linearRampToValueAtTime(150, now + 0.05); g.gain.setValueAtTime(0.01, now); g.gain.linearRampToValueAtTime(0, now + 0.05); osc.connect(g); g.connect(masterGain); osc.start(); osc.stop(now + 0.05); } }

        function resize() {
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            s = Math.min(canvas.width, canvas.height) / 1000;
            player.x = canvas.width / 2; player.y = canvas.height / 2;
            touch.joy.x = 210 * s; touch.joy.y = canvas.height - 210 * s; touch.joy.r = 145 * s;
            touch.btnFire.r = 135 * s; touch.btnFire.x = canvas.width - 170 * s; touch.btnFire.y = canvas.height - 170 * s;
            touch.btnUlt.r = 100 * s; touch.btnUlt.x = canvas.width - 410 * s; touch.btnUlt.y = canvas.height - 150 * s;
            touch.btnPause.r = 60 * s; touch.btnPause.x = canvas.width - 80 * s; touch.btnPause.y = 80 * s;
            initLandscape();
        }

        function spawnSAM() {
            if(!groundSAM) groundSAM = { angle: 0, radarAngle: 0 };
            let safe = false; let attempts = 0;
            const pad = 80 * s; const minPlayerDist = 180 * s; const maxPlayerDist = 380 * s; 
            while(!safe && attempts < 100) {
                const ang = Math.random() * Math.PI * 2;
                const dist = minPlayerDist + Math.random() * (maxPlayerDist - minPlayerDist);
                const cx = player.x + Math.cos(ang) * dist;
                const cy = player.y + Math.sin(ang) * dist;
                if (cx < pad || cx > canvas.width - pad || cy < pad || cy > canvas.height - pad) { attempts++; continue; }
                let overlap = false;
                for(let t of trees) { if(Math.hypot(cx - t.x, cy - t.y) < 90 * s) overlap = true; }
                for(let i of iceBlocks) { if(Math.hypot(cx - i.x, cy - i.y) < 90 * s) overlap = true; }
                if (cx < 400*s && cy > canvas.height - 400*s) overlap = true; 
                if (cx > canvas.width - 400*s && cy > canvas.height - 400*s) overlap = true; 
                if(!overlap) { groundSAM.x = cx; groundSAM.y = cy; safe = true; }
                attempts++;
            }
            if(!safe) { groundSAM.x = player.x; groundSAM.y = player.y - 250*s; }
        }

        function initLandscape() {
            snowflakes = []; trees = []; iceBlocks = [];
            let treeCount = (currentLevel === 3) ? 25 : 20;
            let rockCount = (currentLevel === 3) ? 15 : 10;
            let treeType = (currentLevel === 3) ? 'cactus' : 'tree';
            let rockType = (currentLevel === 3) ? 'rock' : 'ice';

            for(let i=0; i<treeCount; i++) {
                let safe = false, attempts = 0, tx, ty;
                while(!safe && attempts < 50) {
                    tx = Math.random() * canvas.width; ty = Math.random() * canvas.height;
                    let overlap = false;
                    if(Math.hypot(tx - player.x, ty - player.y) < 150*s) overlap = true;
                    for(let t of trees) if(Math.hypot(tx - t.x, ty - t.y) < 60*s) overlap = true;
                    if (tx < 350*s && ty > canvas.height - 350*s) overlap = true;
                    if (tx > canvas.width - 350*s && ty > canvas.height - 350*s) overlap = true;
                    if (Math.abs(tx - canvas.width/2) < 200*s && ty < 150*s) overlap = true;
                    if(!overlap) safe = true;
                    attempts++;
                }
                if(safe) trees.push({ x: tx, y: ty, s: Math.random()*0.5 + 0.4, type: treeType });
            }

            for(let i=0; i<rockCount; i++) {
                let safe = false, attempts = 0, ix, iy;
                while(!safe && attempts < 50) {
                    ix = Math.random() * canvas.width; iy = Math.random() * canvas.height;
                    let overlap = false;
                    if(Math.hypot(ix - player.x, iy - player.y) < 150*s) overlap = true;
                    for(let t of trees) if(Math.hypot(ix - t.x, iy - t.y) < 70*s) overlap = true;
                    for(let b of iceBlocks) if(Math.hypot(ix - b.x, iy - b.y) < 60*s) overlap = true;
                    if (ix < 350*s && iy > canvas.height - 350*s) overlap = true;
                    if (ix > canvas.width - 350*s && iy > canvas.height - 350*s) overlap = true;
                    if (Math.abs(ix - canvas.width/2) < 200*s && iy < 150*s) overlap = true;
                    if(!overlap) safe = true;
                    attempts++;
                }
                if(safe) iceBlocks.push({ x: ix, y: iy, s: Math.random()*0.6 + 0.3, type: rockType });
            }
            if(currentLevel !== 3) {
                for(let i=0; i<45; i++) snowflakes.push({ x: Math.random()*canvas.width, y: Math.random()*canvas.height, r: Math.random()*3*s + 1, v: Math.random()*1 + 0.5 });
            }
            spawnSAM();
        }

        class Particle {
            constructor(x, y, color, type = 'hit') {
                this.x = x; this.y = y; this.color = color; this.type = type;
                let vm = (type === 'smoke') ? 1.2 : (type === 'fire' ? 2 : 10);
                this.v = { x: (Math.random()-0.5)*vm*s, y: (Math.random()-0.5)*vm*s };
                this.alpha = 1; this.r = (type === 'smoke') ? 6*s : 3*s;
            }
            update() { if(!isPaused && !briefingActive){ this.x += this.v.x; this.y += this.v.y; this.alpha -= (this.type === 'smoke') ? 0.02 : 0.04; if(this.type === 'smoke') this.r += 0.2; } }
            draw() { ctx.save(); ctx.globalAlpha = Math.max(0, this.alpha); ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, Math.max(0.1, this.r), 0, Math.PI*2); ctx.fill(); ctx.restore(); }
        }

        function createExplosion(x, y, scale = 1) { 
            playSound('boom');
            for(let i=0; i<15*scale; i++) particles.push(new Particle(x, y, i%2?'#ff9f43':'#2d3436')); 
        }

        function triggerGameOver() {
            isGameOver = true; isDefeated = true;
            createExplosion(player.x, player.y, 5); 
            showFullscreenAd();
            setTimeout(() => { document.getElementById('game-over').style.display = 'flex'; }, 500);
        }

        function triggerVictory() {
            if (victoryTriggered) return;
            victoryTriggered = true;
            showFullscreenAd();
            setTimeout(() => {
                isGameOver = true;
                const t = translations[currentLang];
                document.getElementById('final-kills').innerText = t.kills + kills;
                document.getElementById('victory-screen').style.display = 'flex';
            }, 1500);
        }
        
        function initLevel2() {
            currentLevel = 2; timeLeft = 180; 
            lives = Math.min(lives + 2, maxLives); ultCharges = 5; levelClearedTime = 0; 
            initLandscape(); 
            const t = translations[currentLang];
            document.getElementById('briefing-label').innerHTML = t.level2Label;
            document.getElementById('briefing-text').innerHTML = t.level2Text;
            document.getElementById('briefing-overlay').style.display = 'flex';
            briefingActive = true; projectiles = [];
        }

        function initLevel3() {
            currentLevel = 3; timeLeft = 180; lives = maxLives;
            ultCharges = 5; levelClearedTime = 0;
            initLandscape();
            const t = translations[currentLang];
            document.getElementById('briefing-label').innerHTML = t.level3Label;
            document.getElementById('briefing-text').innerHTML = t.level3Text;
            document.getElementById('briefing-overlay').style.display = 'flex';
            briefingActive = true; projectiles = [];
        }

        class Enemy {
            constructor(type = 'drone') {
                const side = Math.floor(Math.random() * 4);
                if(side == 0) { this.x = Math.random()*canvas.width; this.y = -60; }
                else if(side == 1) { this.x = canvas.width+60; this.y = Math.random()*canvas.height; }
                else if(side == 2) { this.x = Math.random()*canvas.width; this.y = canvas.height+60; }
                else { this.x = -60; this.y = Math.random()*canvas.height; }
                this.type = type;
                let lvlMult = (currentLevel === 2 || currentLevel === 3) ? 1.15 : 1;
                let hpMult = currentLevel === 2 ? 1.2 : (currentLevel === 3 ? 1.5 : 1);
                this.r = (type === 'boss') ? 40*s : 22*s; 
                this.hp = ((type === 'boss') ? 21 : 1) * hpMult; 
                this.speed = ((type === 'boss') ? 0.65*s : (1.5+Math.random())*s) * lvlMult;
                this.pAng = 0; this.angle = 0; this.vx = 0; this.vy = 0;
            }
            update() {
                if(isPaused || isGameOver || briefingActive) return;
                let targetA = Math.atan2(player.y - this.y, player.x - this.x);
                if(this.type === 'boss') turrets.forEach(t => { if(Math.hypot(this.x - t.x, this.y - t.y) < 150*s) targetA += 0.8; });
                this.vx = Math.cos(targetA) * this.speed; this.vy = Math.sin(targetA) * this.speed;
                this.x += this.vx; this.y += this.vy; this.angle = targetA; this.pAng += 0.4;
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y);
                if(this.type === 'drone') {
                    if(currentLevel === 3) { ctx.strokeStyle = '#6c5ce7'; ctx.fillStyle = '#a29bfe'; }
                    else if (currentLevel === 2) { ctx.strokeStyle = '#e17055'; ctx.fillStyle = '#b2bec3'; }
                    else { ctx.strokeStyle = '#2d3436'; ctx.fillStyle = '#636e72'; }
                    ctx.lineWidth = 4*s; ctx.beginPath();
                    ctx.moveTo(-16*s,-16*s); ctx.lineTo(16*s,16*s); ctx.moveTo(16*s,-16*s); ctx.lineTo(-16*s,16*s); ctx.stroke();
                    const ps = [[-16,-16],[16,-16],[16,16],[-16,16]];
                    ps.forEach(p => { ctx.save(); ctx.translate(p[0]*s, p[1]*s); ctx.rotate(this.pAng); ctx.fillStyle='rgba(0,0,0,0.3)'; ctx.fillRect(-9*s, -2*s, 18*s, 4*s); ctx.restore(); });
                    ctx.fillRect(-9*s, -9*s, 18*s, 18*s);
                    ctx.fillStyle = (currentLevel === 3) ? '#ffeaa7' : '#ff7675'; 
                    ctx.beginPath(); ctx.arc(0,0,4*s,0,Math.PI*2); ctx.fill();
                } else {
                    ctx.rotate(this.angle);
                    ctx.fillStyle = '#2d3436'; ctx.fillRect(-30*s,-24*s,60*s,10*s); ctx.fillRect(-30*s,14*s,60*s,10*s);
                    ctx.fillStyle = '#4b6584'; ctx.fillRect(-24*s,-18*s,48*s,36*s);
                    ctx.fillStyle = '#2c3e50'; ctx.beginPath(); ctx.arc(0,0,20*s,0,Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#2d3436'; ctx.fillRect(10*s,-7*s,32*s,14*s); ctx.restore();
                    ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(this.x-35*s, this.y-50*s, 70*s, 8*s);
                    let hpMultComp = currentLevel === 2 ? 1.2 : (currentLevel === 3 ? 1.5 : 1);
                    let maxHpComp = 21 * hpMultComp;
                    ctx.fillStyle = '#e74c3c'; ctx.fillRect(this.x-35*s, this.y-50*s, 70*s*(this.hp/maxHpComp), 8*s);
                }
                ctx.restore();
            }
        }

        class Turret {
            constructor(x, y) { 
                this.x = x; this.y = y; this.angle = 0; this.lastFire = 0; this.maxLife = 1500; this.life = this.maxLife; this.alpha = 1; this.recoilL = 0; this.recoilR = 0; this.side = true; 
                playSound('turret'); for(let i=0; i<15; i++) particles.push(new Particle(x, y, '#54a0ff', 'fire')); this.teleportAnim = 20; 
            }
            update() {
                if(isPaused || isGameOver || briefingActive) return;
                this.life--; if(this.teleportAnim > 0) this.teleportAnim--;
                let best = null; let minDist = 800*s;
                enemies.forEach(e => { let d = Math.hypot(this.x-e.x, this.y-e.y); if(d < minDist) { minDist = d; best = e; } });
                if(best) {
                    const bSpd = 22*s;
                    let targetA = Math.atan2(best.y - this.y, best.x - this.x);
                    let diff = targetA - this.angle;
                    while(diff < -Math.PI) diff += Math.PI*2; while(diff > Math.PI) diff -= Math.PI*2;
                    this.angle += diff * 0.15;
                    if(Math.abs(diff) < 0.2 && Date.now() - this.lastFire > 380) {
                        const bx = 70 * s; const by = (this.side ? -10 : 10) * s; 
                        const px = this.x + Math.cos(this.angle) * bx - Math.sin(this.angle) * by;
                        const py = this.y + Math.sin(this.angle) * bx + Math.cos(this.angle) * by;
                        projectiles.push({ x: px, y: py, v: {x: Math.cos(this.angle)*bSpd, y: Math.sin(this.angle)*bSpd}, power: 1, target: best, isHoming: false, isSecondary: true });
                        if(this.side) this.recoilL = 14; else this.recoilR = 14; this.side = !this.side;
                        this.lastFire = Date.now(); playSound('turret');
                    }
                }
                if(this.recoilL > 0) this.recoilL -= 2; if(this.recoilR > 0) this.recoilR -= 2;
            }
            draw() { 
                ctx.save(); ctx.translate(this.x, this.y); ctx.fillStyle = '#2d3436'; ctx.beginPath(); ctx.arc(0, 0, 30*s, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#34495e'; ctx.lineWidth = 2*s; ctx.stroke();
                ctx.rotate(this.angle); ctx.fillStyle = '#2f3542'; ctx.fillRect((10 - this.recoilL)*s, -14*s, 60*s, 8*s); ctx.fillRect((10 - this.recoilR)*s, 6*s, 60*s, 8*s);
                ctx.fillStyle = '#7f8c8d'; ctx.fillRect((25 - this.recoilL)*s, -14*s, 5*s, 8*s); ctx.fillRect((25 - this.recoilR)*s, 6*s, 5*s, 8*s); ctx.fillRect((40 - this.recoilL)*s, -14*s, 5*s, 8*s); ctx.fillRect((40 - this.recoilR)*s, 6*s, 5*s, 8*s);
                ctx.fillStyle = '#e74c3c'; ctx.fillRect((68 - this.recoilL)*s, -15*s, 6*s, 10*s); ctx.fillRect((68 - this.recoilR)*s, 5*s, 6*s, 10*s);
                ctx.fillStyle = '#4a69bd'; ctx.beginPath(); ctx.moveTo(-20*s, -22*s); ctx.lineTo(15*s, -15*s); ctx.lineTo(25*s, 0); ctx.lineTo(15*s, 15*s); ctx.lineTo(-20*s, 22*s); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#34495e'; ctx.fillRect(-10*s, -5*s, 25*s, 10*s);
                if(this.teleportAnim > 0) { ctx.restore(); ctx.save(); ctx.translate(this.x, this.y); ctx.strokeStyle = '#54a0ff'; ctx.lineWidth = 4 * s; ctx.globalAlpha = this.teleportAnim / 20; ctx.beginPath(); ctx.arc(0, 0, (this.teleportAnim * 3) * s, 0, Math.PI*2); ctx.stroke(); } ctx.restore(); 
            }
        }

        class Rocket {
            constructor() { this.x = groundSAM.x; this.y = groundSAM.y; this.v = 5*s; this.angle = groundSAM.angle; this.life = 180; this.target = null; }
            update() {
                if(isPaused || isGameOver || briefingActive) return;
                let mD = Infinity; enemies.forEach(e => { if(e.type==='boss') return; let d = Math.hypot(this.x-e.x, this.y-e.y); if(d < mD) { mD = d; this.target = e; } });
                if(this.target) {
                    let diff = Math.atan2(this.target.y-this.y, this.target.x-this.x)-this.angle;
                    while(diff < -Math.PI) diff += Math.PI * 2; while(diff > Math.PI) diff -= Math.PI * 2;
                    this.angle += diff * 0.15; this.v += 0.12*s;
                }
                this.x += Math.cos(this.angle)*this.v; this.y += Math.sin(this.angle)*this.v; this.life--;
                particles.push(new Particle(this.x, this.y, '#ff9f43', 'fire'));
                if(this.life % 2 === 0) particles.push(new Particle(this.x, this.y, 'rgba(255,255,255,0.7)', 'smoke'));
            }
            draw() { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle = '#2d3436'; ctx.fillRect(-11*s, -4*s, 22*s, 7*s); ctx.fillStyle = '#e74c3c'; ctx.beginPath(); ctx.moveTo(11*s, -4*s); ctx.lineTo(18*s, 0); ctx.lineTo(11*s, 4*s); ctx.fill(); ctx.restore(); }
        }

        function drawSAMStation() {
            if(!groundSAM) return; groundSAM.radarAngle += 0.12;
            let t = null; let mD = 850*s; enemies.forEach(e => { let d = Math.hypot(groundSAM.x-e.x, groundSAM.y-e.y); if(d < mD) { mD = d; t = e; } });
            if(t && !isPaused && !isGameOver && !briefingActive) {
                let diff = Math.atan2(t.y-groundSAM.y, t.x-groundSAM.x) - groundSAM.angle;
                while(diff < -Math.PI) diff += Math.PI * 2; while(diff > Math.PI) diff -= Math.PI * 2;
                groundSAM.angle += diff * 0.05;
            }
            ctx.save(); ctx.translate(groundSAM.x, groundSAM.y); ctx.fillStyle = '#2c3e50'; ctx.fillRect(-40*s,-40*s,80*s,80*s); ctx.fillStyle='#34495e'; ctx.fillRect(-50*s,15*s,20*s,20*s); ctx.fillRect(30*s,15*s,20*s,20*s); ctx.fillRect(-50*s,-35*s,20*s,20*s); ctx.fillRect(30*s,-35*s,20*s,20*s);
            ctx.rotate(groundSAM.angle); ctx.fillStyle='#2d3436'; ctx.fillRect(-22*s,-28*s,50*s,56*s); ctx.fillStyle='#1e272e'; ctx.fillRect(12*s,-22*s,17*s,14*s); ctx.fillRect(12*s,8*s,17*s,14*s);
            ctx.save(); ctx.translate(-18*s,0); ctx.rotate(groundSAM.radarAngle); ctx.strokeStyle='#95a5a6'; ctx.lineWidth=3*s; ctx.beginPath(); ctx.arc(0,0,14*s,0,Math.PI); ctx.stroke(); ctx.restore(); ctx.restore();
        }

        function drawPlayer() {
            if(isDefeated) return; 
            if(!isPaused && !briefingActive && !isGameOver) {
                let diff = player.targetAngle - player.angle; while(diff < -Math.PI) diff += Math.PI*2; while(diff > Math.PI) diff -= Math.PI*2;
                if(Math.abs(diff) > 0.01) player.angle += Math.sign(diff) * Math.min(Math.abs(diff), player.turnSpeed);
            }
            const barW = 120*s; const barH = 12*s; ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(player.x - barW/2, player.y - 95*s, barW, barH);
            const hpP = Math.max(0, lives / maxLives); ctx.fillStyle = hpP > 0.5 ? '#2ecc71' : (hpP > 0.25 ? '#f1c40f' : '#e74c3c');
            ctx.fillRect(player.x - barW/2, player.y - 95*s, barW * hpP, barH);
            ctx.save(); ctx.beginPath(); ctx.moveTo(player.x, player.y); ctx.lineTo(player.x + Math.cos(player.angle)*1500*s, player.y + Math.sin(player.angle)*1500*s); ctx.strokeStyle = 'rgba(255, 0, 0, 0.25)'; ctx.lineWidth = 1.5*s; ctx.stroke(); ctx.restore();
            ctx.save(); ctx.translate(player.x, player.y); ctx.fillStyle = '#34495e'; ctx.beginPath(); ctx.moveTo(-50*s, 50*s); ctx.lineTo(50*s, 50*s); ctx.lineTo(60*s, 22*s); ctx.lineTo(60*s, -22*s); ctx.lineTo(50*s, -50*s); ctx.lineTo(-50*s, -50*s); ctx.lineTo(-60*s, -22*s); ctx.lineTo(-60*s, 22*s); ctx.fill();
            ctx.fillStyle = '#e74c3c'; ctx.fillRect(-35*s, 38*s, 70*s, 6*s); ctx.fillRect(-35*s, -44*s, 70*s, 6*s); ctx.rotate(player.angle);
            ctx.fillStyle = '#4a69bd'; ctx.beginPath(); ctx.moveTo(-32*s,-28*s); ctx.lineTo(22*s,-28*s); ctx.lineTo(38*s,-11*s); ctx.lineTo(38*s,11*s); ctx.lineTo(22*s,28*s); ctx.lineTo(-32*s,28*s); ctx.fill(); ctx.strokeStyle = '#2c3e50'; ctx.lineWidth = 3*s; ctx.beginPath(); ctx.moveTo(0, -28*s); ctx.lineTo(0, 28*s); ctx.stroke();
            ctx.fillStyle = '#2c3e50'; ctx.fillRect((32-player.recoil)*s, -9*s, 65*s, 18*s); for(let i=0; i<5; i++) { ctx.fillStyle = '#7f8c8d'; ctx.fillRect((42+i*11-player.recoil)*s, -10*s, 5*s, 20*s); }
            ctx.fillStyle = '#2c3e50'; ctx.fillRect((95-player.recoil)*s, -13*s, 17*s, 26*s); ctx.fillStyle = '#e74c3c'; ctx.fillRect((105-player.recoil)*s, -7*s, 6*s, 14*s); ctx.beginPath(); ctx.arc(0,0,20*s,0,Math.PI*2); ctx.fillStyle='#34495e'; ctx.fill(); ctx.fillStyle='#e74c3c'; ctx.fillRect(-11*s, -5*s, 22*s, 11*s); ctx.restore();
        }

        function drawBtn(x, y, r, act, col, ico) { ctx.save(); if(act) ctx.translate(0, 6*s); ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fillStyle = col; ctx.fill(); ctx.strokeStyle='white'; ctx.lineWidth=5*s; ctx.stroke(); ctx.fillStyle = 'white'; ctx.font = `${r*0.8}px serif`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(ico, x, y); ctx.restore(); }

        function animate() {
            if(!isRunning) return; requestAnimationFrame(animate);
            if (currentLevel === 3) ctx.fillStyle = '#f7d794'; else if (currentLevel === 2) ctx.fillStyle = '#131a21'; else ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0,0,canvas.width,canvas.height);
            iceBlocks.forEach(ib => { ctx.save(); ctx.translate(ib.x, ib.y); ctx.scale(ib.s*s*1.2, ib.s*s*1.2); if(ib.type === 'rock') { ctx.fillStyle = '#7f8c8d'; ctx.beginPath(); ctx.moveTo(-20, -15); ctx.lineTo(15, -20); ctx.lineTo(25, 5); ctx.lineTo(0, 20); ctx.lineTo(-25, 10); ctx.closePath(); ctx.fill(); } else { ctx.fillStyle = '#D1EAF5'; ctx.beginPath(); ctx.moveTo(0, -30); ctx.lineTo(25, -10); ctx.lineTo(20, 20); ctx.lineTo(-20, 25); ctx.lineTo(-25, 0); ctx.closePath(); ctx.fill(); } ctx.restore(); });
            trees.forEach(t => { ctx.save(); ctx.translate(t.x, t.y); let scaleMult = t.type === 'cactus' ? 1.35 : 1.2; ctx.scale(t.s*s*scaleMult, t.s*s*scaleMult); if(t.type === 'cactus') { ctx.fillStyle = '#27ae60'; ctx.beginPath(); ctx.roundRect(-12, -60, 24, 70, 12); ctx.fill(); ctx.fillStyle = '#2ecc71'; ctx.fillRect(-4, -58, 8, 68); ctx.fillStyle = '#27ae60'; ctx.beginPath(); ctx.roundRect(-35, -40, 25, 12, 6); ctx.fill(); ctx.beginPath(); ctx.roundRect(-35, -55, 12, 20, 6); ctx.fill(); ctx.beginPath(); ctx.roundRect(10, -25, 25, 12, 6); ctx.fill(); ctx.beginPath(); ctx.roundRect(23, -40, 12, 20, 6); ctx.fill(); } else { ctx.fillStyle = '#5D4037'; ctx.fillRect(-4, 0, 8, 15); ctx.fillStyle = '#1B5E20'; ctx.beginPath(); ctx.moveTo(-35, 5); ctx.lineTo(35, 5); ctx.lineTo(0, -25); ctx.moveTo(-30, -15); ctx.lineTo(30, -15); ctx.lineTo(0, -45); ctx.moveTo(-20, -35); ctx.lineTo(20, -35); ctx.lineTo(0, -65); ctx.fill(); } ctx.restore(); });
            if(currentLevel !== 3) snowflakes.forEach(f => { ctx.beginPath(); ctx.arc(f.x, f.y, f.r, 0, Math.PI*2); ctx.fillStyle='#E3F2FD'; ctx.fill(); if(!isPaused && !briefingActive) f.y += f.v; if(f.y > canvas.height) f.y = -10; });
            if(!isPaused && !isGameOver && !briefingActive) { if (timeLeft > 0) { if(kills % 15 === 0 && kills > 0 && enemies.filter(e=>e.type==='boss').length === 0) enemies.push(new Enemy('boss')); let spawnRate = (currentLevel === 2) ? 0.025 : (currentLevel === 3 ? 0.028 : 0.02); if(Math.random() < spawnRate) enemies.push(new Enemy('drone')); levelClearedTime = 0; } else { if (enemies.length === 0 && !victoryTriggered) { if (levelClearedTime === 0) levelClearedTime = Date.now(); if (Date.now() - levelClearedTime > 2000) { if (currentLevel === 1) initLevel2(); else if (currentLevel === 2) initLevel3(); else triggerVictory(); } } } }
            drawSAMStation(); drawPlayer(); 
            if(!isPaused && !isGameOver && !briefingActive) { if(touch.btnFire.active && Date.now() - lastShotTime > 180) { const barrelLen = 115 * s; const px = player.x + Math.cos(player.angle) * barrelLen; const py = player.y + Math.sin(player.angle) * barrelLen; projectiles.push({ x: px, y: py, v: {x: Math.cos(player.angle)*25*s, y: Math.sin(player.angle)*25*s}, power: 1.2 }); player.recoil = 18; lastShotTime = Date.now(); playSound('shoot'); }
                if(player.recoil > 0) player.recoil -= 2;
                projectiles.forEach((p, i) => { p.x += p.v.x; p.y += p.v.y; ctx.fillStyle = '#FFD54F'; ctx.beginPath(); ctx.arc(p.x, p.y, 6*s, 0, Math.PI*2); ctx.fill(); enemies.forEach((e, ei) => { if (Math.hypot(p.x - e.x, p.y - e.y) < e.r + 5*s) { if (p.isSecondary) { if (e.type === 'boss') e.hp -= 0.1; else e.hp = 0; } else { e.hp -= (p.power || 1); } if(e.hp <= 0) { createExplosion(e.x, e.y, e.type==='boss'?3.5:1); enemies.splice(ei, 1); kills++; } projectiles.splice(i, 1); } }); if(p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) projectiles.splice(i, 1); }); }
            turrets.forEach((t, i) => { t.update(); t.draw(); if(t.life <= 0) { createExplosion(t.x, t.y); turrets.splice(i, 1); } }); rockets.forEach((r, i) => { r.update(); r.draw(); enemies.forEach((e, ei) => { if(e.type !== 'boss' && Math.hypot(r.x-e.x, r.y-e.y) < e.r+10*s) { createExplosion(e.x, e.y); enemies.splice(ei, 1); rockets.splice(i, 1); kills++; } }); }); enemies.forEach((e, i) => { e.update(); e.draw(); if(!isGameOver && !victoryTriggered && Math.hypot(player.x - e.x, player.y - e.y) < player.radius*s) { createExplosion(e.x, e.y); lives -= e.type==='boss'?2:1; enemies.splice(i, 1); if(lives <= 0) triggerGameOver(); } }); particles.forEach((p, i) => { p.update(); p.draw(); if(p.alpha <= 0) particles.splice(i, 1); });
            if(!isGameOver) { let jX = touch.joy.x, jY = touch.joy.y; if(touch.joy.active && !isPaused && !briefingActive) { const dx = touch.joy.curX-touch.joy.startX, dy = touch.joy.curY-touch.joy.startY; const d = Math.min(Math.hypot(dx, dy), touch.joy.r); player.targetAngle = Math.atan2(dy, dx); jX += Math.cos(player.targetAngle)*d; jY += Math.sin(player.targetAngle)*d; } else if(!isPaused && !briefingActive) { jX += Math.cos(player.targetAngle) * (touch.joy.r * 0.5); jY += Math.sin(player.targetAngle) * (touch.joy.r * 0.5); }
                ctx.beginPath(); ctx.arc(touch.joy.x, touch.joy.y, touch.joy.r, 0, Math.PI*2); ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fill(); ctx.beginPath(); ctx.arc(jX, jY, 45*s, 0, Math.PI*2); ctx.fillStyle = '#2d3436'; ctx.fill(); drawBtn(touch.btnFire.x, touch.btnFire.y, touch.btnFire.r, touch.btnFire.active, '#ff6b81', 'üéØ');
                let uCol = (ultCharges > 0) ? ((Date.now()-lastUltTime>5000) ? '#f1c40f' : '#95a5a6') : '#2ecc71'; let uIcon = (ultCharges > 0) ? '‚ò¢Ô∏è' : 'üì∫'; drawBtn(touch.btnUlt.x, touch.btnUlt.y, touch.btnUlt.r, touch.btnUlt.active, uCol, uIcon); ctx.fillStyle = uCol; ctx.font = `bold ${25*s}px sans-serif`; ctx.textAlign = 'center'; ctx.fillText(ultCharges, touch.btnUlt.x, touch.btnUlt.y - touch.btnUlt.r - 15*s); drawBtn(touch.btnPause.x, touch.btnPause.y, touch.btnPause.r, false, '#34495e', isPaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è'); }
            
            let t = translations[currentLang]; 
            let timeStr = ""; 
            if (timeLeft > 0) { 
                const mins = Math.floor(timeLeft / 60); const secs = timeLeft % 60; 
                timeStr = (mins < 10 ? '0' : '') + mins + ':' + (secs < 10 ? '0' : '') + secs; 
                ctx.fillStyle = (currentLevel === 3) ? '#2d3436' : (currentLevel === 2 ? '#ecf0f1' : '#2d3436'); 
            } else { 
                timeStr = t.clean; 
                ctx.fillStyle = '#ff4757'; 
            }
            ctx.font = `bold ${32*s}px monospace`; ctx.textAlign='center'; ctx.fillText(timeStr, canvas.width/2, 60*s); 
            ctx.font = `bold ${20*s}px monospace`; ctx.fillText("LVL " + currentLevel, canvas.width/2, 90*s);
            
            // --- –õ–û–ì–ò–ö–ê –°–ö–†–´–¢–ò–Ø –ö–£–†–°–û–†–ê –í–û –í–†–ï–ú–Ø –ò–ì–†–´ ---
            if (!isPaused && !isGameOver && !briefingActive) {
                // –ï—Å–ª–∏ –∏–¥–µ—Ç –∏–≥—Ä–∞ –∏ –Ω–µ—Ç –º–µ–Ω—é - —Å–∫—Ä—ã–≤–∞–µ–º –∫—É—Ä—Å–æ—Ä
                canvas.style.cursor = 'none';
            } else {
                // –í –º–µ–Ω—é –∏ –ø–∞—É–∑–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º
                canvas.style.cursor = 'default';
                
                // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ø–∞—É–∑—ã
                if(isPaused) { 
                    ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0,0,canvas.width,canvas.height); 
                    ctx.fillStyle = 'white'; ctx.font = `bold ${60*s}px sans-serif`; ctx.textAlign='center'; 
                    ctx.fillText(t.pause, canvas.width/2, canvas.height/2); 
                }
            }
            // ---------------------------------------------

            if(flashAlpha > 0) { ctx.fillStyle = `rgba(255, 255, 255, ${flashAlpha})`; ctx.fillRect(0, 0, canvas.width, canvas.height); flashAlpha -= 0.05; }
        }

        function startGame() { 
            const docEl = document.documentElement; const requestFS = docEl.requestFullscreen || docEl.webkitRequestFullscreen || docEl.mozRequestFullScreen || docEl.msRequestFullscreen; if (requestFS) requestFS.call(docEl).catch(err => {});
            if (screen.orientation && screen.orientation.lock) screen.orientation.lock('landscape').catch(err => {});
            initAudio(); document.getElementById('start-screen').style.display='none'; canvas.style.display='block'; isRunning=true; briefingActive = true; document.getElementById('briefing-overlay').style.display='flex'; resize(); lastRocketTime = Date.now();
            showFullscreenAd(); animate(); 
        }

        function startBattle() { 
            briefingActive = false; document.getElementById('briefing-overlay').style.display='none'; lastRocketTime = Date.now();
            showFullscreenAd(); // –î–æ–ø. –ø—Ä–æ–≤–µ—Ä–∫–∞ SDK –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –±—Ä–∏—Ñ–∏–Ω–≥–∞
        }
        window.addEventListener('resize', resize);
        
        setInterval(() => { if(isRunning && !isPaused && !isGameOver && !briefingActive) { if(timeLeft > 0) timeLeft--; if(Date.now()-lastRocketTime > 2500 && enemies.length > 0) { rockets.push(new Rocket()); lastRocketTime = Date.now(); } if(Date.now()-lastTurretTime > 8000) { let tx, ty, foundSpot = false, attempts = 0; while(!foundSpot && attempts < 15) { tx = player.x + (Math.random()-0.5)*800*s; ty = player.y + (Math.random()-0.5)*800*s; let overlap = false; if(Math.hypot(tx - player.x, ty - player.y) < 250*s) overlap = true; if(Math.hypot(tx - groundSAM.x, ty - groundSAM.y) < 150*s) overlap = true; for(let t of trees) if(Math.hypot(tx - t.x, ty - t.y) < 90*s) overlap = true; for(let i of iceBlocks) if(Math.hypot(tx - i.x, ty - i.y) < 90*s) overlap = true; for(let tur of turrets) if(Math.hypot(tx - tur.x, ty - tur.y) < 100*s) overlap = true; if (tx < 350*s && ty > canvas.height - 350*s) overlap = true; if (tx > canvas.width - 350*s && ty > canvas.height - 350*s) overlap = true; if (Math.abs(tx - canvas.width/2) < 200*s && ty < 150*s) overlap = true; if(!overlap) foundSpot = true; attempts++; } if(foundSpot) { turrets.push(new Turret(tx, ty)); lastTurretTime = Date.now(); } } } }, 1000);

        canvas.addEventListener('touchstart', e => { e.preventDefault(); if(briefingActive) return; for(let t of e.changedTouches) { if(isGameOver) return; if(Math.hypot(t.clientX - touch.btnPause.x, t.clientY - touch.btnPause.y) < touch.btnPause.r) { isPaused = !isPaused; return; } if(isPaused) { isPaused = false; return; } if(t.clientX < canvas.width/2) { touch.joy.active=true; touch.joy.id=t.identifier; touch.joy.startX=t.clientX; touch.joy.startY=t.clientY; touch.joy.curX=t.clientX; touch.joy.curY=t.clientY; } if(Math.hypot(t.clientX - touch.btnFire.x, t.clientY - touch.btnFire.y) < touch.btnFire.r) touch.btnFire.active = true; if(Math.hypot(t.clientX - touch.btnUlt.x, t.clientY - touch.btnUlt.y) < touch.btnUlt.r) { if (ultCharges > 0 && Date.now() - lastUltTime > 5000) { enemies.forEach(en => { createExplosion(en.x, en.y, en.type==='boss'?2.5:1); kills++; }); enemies.length = 0; lastUltTime=Date.now(); ultCharges--; flashAlpha = 0.35; } else if (ultCharges <= 0) { showRewardedAd(); } } } }, {passive: false});
        canvas.addEventListener('touchmove', e => { e.preventDefault(); for (let t of e.touches) if (t.identifier === touch.joy.id) { touch.joy.curX = t.clientX; touch.joy.curY = t.clientY; } }, {passive: false});
        canvas.addEventListener('touchend', e => { for(let t of e.changedTouches) { if(t.identifier===touch.joy.id) touch.joy.active=false; if(Math.hypot(t.clientX - touch.btnFire.x, t.clientY - touch.btnFire.y) < touch.btnFire.r) touch.btnFire.active=false; } });
        canvas.addEventListener('mousemove', e => { if (isGameOver || isPaused || briefingActive) return; const dx = e.clientX - player.x; const dy = e.clientY - player.y; player.targetAngle = Math.atan2(dy, dx); });
        canvas.addEventListener('mousedown', e => { if (isGameOver || briefingActive) return; if (e.button === 0) touch.btnFire.active = true; if (e.button === 2) { if (ultCharges > 0 && Date.now() - lastUltTime > 5000) { enemies.forEach(en => { createExplosion(en.x, en.y, en.type==='boss'?2.5:1); kills++; }); enemies.length = 0; lastUltTime = Date.now(); ultCharges--; touch.btnUlt.active = true; setTimeout(() => touch.btnUlt.active = false, 200); flashAlpha = 0.35; } else if (ultCharges <= 0) { showRewardedAd(); } } });
        canvas.addEventListener('mouseup', e => { if (e.button === 0) touch.btnFire.active = false; });
        canvas.addEventListener('contextmenu', e => e.preventDefault());
        window.addEventListener('keydown', e => { if (e.code === 'KeyG') isPaused = !isPaused; });
    </script>
</body>
</html>